/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rpe_ResourcePackEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rpe/ResourcePackEditor */ \"./src/rpe/ResourcePackEditor.ts\");\n/* harmony import */ var _rpe_event_RPEEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rpe/event/RPEEvent */ \"./src/rpe/event/RPEEvent.ts\");\n/* harmony import */ var _rpe_event_RPESaveEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rpe/event/RPESaveEvent */ \"./src/rpe/event/RPESaveEvent.ts\");\n\r\n\r\n\r\nwindow[\"RPEEvent\"] = _rpe_event_RPEEvent__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\r\nwindow[\"RPESaveEvent\"] = _rpe_event_RPESaveEvent__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\r\nlet e = new _rpe_event_RPEEvent__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\r\nconsole.log(\"generic:\", e.getID());\r\ne = new _rpe_event_RPESaveEvent__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\r\nconsole.log(\"save:\", e.getID());\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/index.ts?");

/***/ }),

/***/ "./src/rpe/ResourcePackEditor.ts":
/*!***************************************!*\
  !*** ./src/rpe/ResourcePackEditor.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _game_RPESupportedGameEntry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game/RPESupportedGameEntry */ \"./src/rpe/game/RPESupportedGameEntry.ts\");\n/* harmony import */ var _util_Future__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/Future */ \"./src/rpe/util/Future.ts\");\nvar _a;\r\n\r\n\r\nconst ResourcePackEditor = new (_a = class ResourcePackEditor {\r\n        constructor() {\r\n            /**\r\n             * A map containing the loaded games.\r\n             */\r\n            this.loadedGames = new Map();\r\n            /**\r\n             * This variable contains a cached array of the supported\r\n             * games. Initially this is empty, and after the first call to\r\n             * {@link ResourcePackEditor.reloadAvailableGames()}, this will\r\n             * be populated when the available games have loaded.\r\n             */\r\n            this.availableGames = new Map();\r\n        }\r\n        /**\r\n         * Returns a Future which will resolve with a map of\r\n         * supported game ID to supported game entry.\r\n         * @returns a Future\r\n         */\r\n        reloadAvailableGames() {\r\n            return this._availableGamesFutureCache = _util_Future__WEBPACK_IMPORTED_MODULE_1__[\"default\"].asyncFuture(fetch(\"assets/data/games.json\").then(r => r.json()).then(data => {\r\n                this.availableGames.clear();\r\n                for (let key of Object.keys(data)) {\r\n                    this.availableGames.set(key, new _game_RPESupportedGameEntry__WEBPACK_IMPORTED_MODULE_0__[\"default\"](data[key]));\r\n                }\r\n                return this.availableGames;\r\n            }));\r\n        }\r\n        /**\r\n         * Returns a Future which will resolve with a map of\r\n         * supported game ID to supported game entry.\r\n         *\r\n         * This method only calls {@link ResourcePackEditor.reloadAvailableGames()}\r\n         * if it has not been called before. Further invocations return\r\n         * a cached Future instance.\r\n         * @returns a Future\r\n         */\r\n        loadAvailableGames() {\r\n            if (this._availableGamesFutureCache)\r\n                return this._availableGamesFutureCache;\r\n            return this.reloadAvailableGames();\r\n        }\r\n        /**\r\n         * Tries to load an RPEGame by the specified ID.\r\n         * @param id the id of the game to load\r\n         * @returns a new Future\r\n         */\r\n        loadGame(id) {\r\n            if (this.loadedGames.has(id)) {\r\n                return _util_Future__WEBPACK_IMPORTED_MODULE_1__[\"default\"].completedFuture(this.loadedGames.get(id));\r\n            }\r\n            else if (this.availableGames.has(id)) {\r\n                return this.availableGames.get(id).loadGame();\r\n            }\r\n            else {\r\n                return _util_Future__WEBPACK_IMPORTED_MODULE_1__[\"default\"].failedFuture(new Error(\"Game \\\"\" + id + \"\\\" is not supported and could not be loaded.\"));\r\n            }\r\n        }\r\n        /**\r\n         * Registers a game instance.\r\n         * @param game the game instance to register\r\n         */\r\n        registerGame(game) {\r\n            this.loadedGames[game.id] = game;\r\n        }\r\n    },\r\n    /*\r\n    packManager: {\r\n        /**\r\n         * /\r\n        loadedPacks: [],\r\n        vanillaPack: null,\r\n        async loadFilePack(writable) {\r\n            \r\n        },\r\n        async loadFolderPack(writable) {\r\n            \r\n        },\r\n        async loadPackUrl(url) {\r\n            let packBlob = await (await fetch(url)).blob();\r\n            let zipReader = new zip.ZipReader(new zip.BlobReader(packBlob));\r\n            \r\n            let pack = new ZipArchive(zipReader);\r\n            if (vanillaPack != null) {\r\n                loadedPacks.splice(loadedPacks.splice(loadedPacks.length-1, 0, pack));\r\n            }\r\n            this._loadPack(pack);\r\n            return pack;\r\n        },\r\n        async loadVanillaPack(versionString) {\r\n\r\n        },\r\n        /**\r\n         * Adds the specified pack.\r\n         * @param pack the pack to add\r\n         * /\r\n        private _loadPack(pack) {\r\n            this.loadedPacks.push(pack);\r\n        }\r\n    },\r\n    /**\r\n     * /\r\n    versionSupport: null,\r\n    init() {\r\n    },\r\n    getPackEntry(path, startPackIndex) {\r\n        if (startPackIndex == undefined) startPackIndex = this.packManager.loadedPacks.length-1;\r\n        for (let i = startPackIndex; i >= 0; i--) {\r\n            const pack = this.packManager.loadedPacks[i];\r\n            let entry = pack.getEntry(path);\r\n            if (entry != null) return entry;\r\n        }\r\n    }\r\n    */\r\n    _a.EDITOR_VERSION = \"0.0.1\",\r\n    _a);\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ResourcePackEditor);\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/ResourcePackEditor.ts?");

/***/ }),

/***/ "./src/rpe/error/CancellationError.ts":
/*!********************************************!*\
  !*** ./src/rpe/error/CancellationError.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CancellationError)\n/* harmony export */ });\n/* harmony import */ var _JError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JError */ \"./src/rpe/error/JError.ts\");\n\r\nclass CancellationError extends _JError__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n}\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/error/CancellationError.ts?");

/***/ }),

/***/ "./src/rpe/error/Completion.ts":
/*!*************************************!*\
  !*** ./src/rpe/error/Completion.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CompletionError)\n/* harmony export */ });\n/* harmony import */ var _JError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JError */ \"./src/rpe/error/JError.ts\");\n\r\nclass CompletionError extends _JError__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n}\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/error/Completion.ts?");

/***/ }),

/***/ "./src/rpe/error/ExecutionError.ts":
/*!*****************************************!*\
  !*** ./src/rpe/error/ExecutionError.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ExecutionError)\n/* harmony export */ });\n/* harmony import */ var _JError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JError */ \"./src/rpe/error/JError.ts\");\n\r\nclass ExecutionError extends _JError__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n}\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/error/ExecutionError.ts?");

/***/ }),

/***/ "./src/rpe/error/JError.ts":
/*!*********************************!*\
  !*** ./src/rpe/error/JError.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ JError)\n/* harmony export */ });\n/**\r\n * A class for extended Error functionality,\r\n * including nested errors.\r\n */\r\nclass JError extends Error {\r\n    /**\r\n     * Creates a new UnsupportedOperationError.\r\n     * @param message the operation that was unsupported\r\n     * @param cause an optional error that caused this UnsupportedOperationError\r\n     */\r\n    constructor(message = undefined, cause = undefined) {\r\n        super(message);\r\n        this.message = message;\r\n        this.cause = cause;\r\n        this.name = this.constructor[\"name\"];\r\n        if (cause)\r\n            this.stack += \"\\nCaused by: \" + cause.stack;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/error/JError.ts?");

/***/ }),

/***/ "./src/rpe/error/TimeoutError.ts":
/*!***************************************!*\
  !*** ./src/rpe/error/TimeoutError.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TimeoutError)\n/* harmony export */ });\nclass TimeoutError extends Error {\r\n    /**\r\n     * Creates a new TimeoutError.\r\n     * @param duration the duration after the timeout was reached\r\n     * @param unit the TimeUnit in which duration is interpreted\r\n     * @param timeunitTarget the timeunit target\r\n     */\r\n    constructor(duration, unit, timeunitTarget = undefined) {\r\n        super((timeunitTarget ? \"Timeout on \" + timeunitTarget + \" reached after \" : \"Timeout reached after \") + (unit == null ? \"an unknown duration\" : unit.stringify(duration)));\r\n        this.name = \"TimeoutError\";\r\n        this._duration = duration;\r\n        this._unit = unit;\r\n        this._timeunitTarget = timeunitTarget;\r\n    }\r\n    /**\r\n     * The duration after the timeout was reached.\r\n     * This is interpreted in the {@link TimeUnit}\r\n     * represented by {@link TimeoutError.unit `unit`},\r\n     * or `null` if unknown.\r\n     */\r\n    get duration() {\r\n        return this._duration;\r\n    }\r\n    /**\r\n     * The unit in which {@link TimeoutError.duration `duration`}\r\n     * is interpreted, or `null` if unknown.\r\n     */\r\n    get unit() {\r\n        return this._unit;\r\n    }\r\n    /**\r\n     * The timeout target.\r\n     */\r\n    get timeunitTarget() {\r\n        return this._timeunitTarget;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/error/TimeoutError.ts?");

/***/ }),

/***/ "./src/rpe/event/RPEEvent.ts":
/*!***********************************!*\
  !*** ./src/rpe/event/RPEEvent.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RPEEvent)\n/* harmony export */ });\nclass RPEEvent {\r\n    getID() {\r\n        return this.constructor[\"EVENT_ID\"];\r\n    }\r\n}\r\nRPEEvent.EVENT_ID = null;\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/event/RPEEvent.ts?");

/***/ }),

/***/ "./src/rpe/event/RPESaveEvent.ts":
/*!***************************************!*\
  !*** ./src/rpe/event/RPESaveEvent.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RPESaveEvent)\n/* harmony export */ });\n/* harmony import */ var _RPEEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RPEEvent */ \"./src/rpe/event/RPEEvent.ts\");\n\r\nclass RPESaveEvent extends _RPEEvent__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor() {\r\n        super();\r\n    }\r\n}\r\nRPESaveEvent.EVENT_ID = \"rpe:save\";\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/event/RPESaveEvent.ts?");

/***/ }),

/***/ "./src/rpe/game/RPESupportedGameEntry.ts":
/*!***********************************************!*\
  !*** ./src/rpe/game/RPESupportedGameEntry.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RPESupportedGameEntry)\n/* harmony export */ });\n/* harmony import */ var _ResourcePackEditor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ResourcePackEditor */ \"./src/rpe/ResourcePackEditor.ts\");\n/* harmony import */ var _util_Future__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/Future */ \"./src/rpe/util/Future.ts\");\n/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Utils */ \"./src/rpe/util/Utils.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass RPESupportedGameEntry {\r\n    constructor(data) {\r\n        this.id = data.id;\r\n        this.name = data.name;\r\n        this.logo = data.logo;\r\n        this._loadedGameFuture = null;\r\n    }\r\n    loadGame() {\r\n        if (this._loadedGameFuture)\r\n            return this._loadedGameFuture;\r\n        this._loadedGameFuture = _util_Future__WEBPACK_IMPORTED_MODULE_1__[\"default\"].asyncFuture(() => __awaiter(this, void 0, void 0, function* () {\r\n            _util_Utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"].loadScript(\"assets/game/\" + this.id + \".js\");\r\n            return _ResourcePackEditor__WEBPACK_IMPORTED_MODULE_0__[\"default\"].loadedGames[this.id];\r\n        }));\r\n        return this._loadedGameFuture;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/game/RPESupportedGameEntry.ts?");

/***/ }),

/***/ "./src/rpe/util/Future.ts":
/*!********************************!*\
  !*** ./src/rpe/util/Future.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Future)\n/* harmony export */ });\n/* harmony import */ var _error_CancellationError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../error/CancellationError */ \"./src/rpe/error/CancellationError.ts\");\n/* harmony import */ var _error_Completion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../error/Completion */ \"./src/rpe/error/Completion.ts\");\n/* harmony import */ var _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../error/ExecutionError */ \"./src/rpe/error/ExecutionError.ts\");\n/* harmony import */ var _error_TimeoutError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../error/TimeoutError */ \"./src/rpe/error/TimeoutError.ts\");\n/* harmony import */ var _TimeUnit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TimeUnit */ \"./src/rpe/util/TimeUnit.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar _a;\r\n\r\n\r\n\r\n\r\n\r\nvar FutureState;\r\n(function (FutureState) {\r\n    FutureState[FutureState[\"INCOMPLETE\"] = 0] = \"INCOMPLETE\";\r\n    FutureState[FutureState[\"CANCELLED\"] = 1] = \"CANCELLED\";\r\n    FutureState[FutureState[\"COMPLETED_SUCCESS\"] = 2] = \"COMPLETED_SUCCESS\";\r\n    FutureState[FutureState[\"COMPLETED_EXCEPTIONALLY\"] = 3] = \"COMPLETED_EXCEPTIONALLY\";\r\n})(FutureState || (FutureState = {}));\r\n/**\r\n * The JS equivalent of Java's CompletableFuture.\r\n * @template T the type of the result\r\n */\r\nclass Future {\r\n    /**\r\n     * Creates a new incomplete Future.\r\n     */\r\n    constructor() {\r\n        this[_a] = \"Future\";\r\n        this._result = null;\r\n        this._error = null;\r\n        this._state = FutureState.INCOMPLETE;\r\n        this._childrenCount = 0;\r\n        this._completionPromise = new Promise((resolve, reject) => {\r\n            this._completionPromiseResolve = resolve;\r\n            this._completionPromiseReject = reject;\r\n        });\r\n    }\r\n    /**\r\n     * The promise `then()` method.\r\n     * @param completionHandler the completion handler, will be called on successful completion\r\n     * @param errorHandler the error handler, will be called on unsuccessful completion\r\n     * @returns a new Future\r\n     * @template TCompletionResult the result from the completionHandler\r\n     * @template TErrorResult the result from the error handler\r\n     */\r\n    then(completionHandler, errorHandler) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                let value = completionHandler(result);\r\n                if (value instanceof Promise) {\r\n                    value.then(result => {\r\n                        future.complete(result);\r\n                    }, error => {\r\n                        future.completeExceptionally(error);\r\n                    });\r\n                }\r\n                else {\r\n                    future.complete(value);\r\n                }\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            try {\r\n                let value = errorHandler(error);\r\n                if (value instanceof Promise) {\r\n                    value.then(result => {\r\n                        future.complete(result);\r\n                    }, error => {\r\n                        future.completeExceptionally(error);\r\n                    });\r\n                }\r\n                else {\r\n                    future.complete(value);\r\n                }\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        });\r\n        return future;\r\n    }\r\n    catch(errorHandler) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.catch(error => {\r\n            try {\r\n                let value = errorHandler(error);\r\n                if (value instanceof Promise) {\r\n                    value.then(result => {\r\n                        future.complete(result);\r\n                    }, error => {\r\n                        future.completeExceptionally(error);\r\n                    });\r\n                }\r\n                else {\r\n                    future.complete(value);\r\n                }\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        });\r\n        return future;\r\n    }\r\n    finally(onfinally) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                if (onfinally)\r\n                    onfinally();\r\n                future.complete(result);\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            try {\r\n                if (onfinally)\r\n                    onfinally();\r\n                future.completeExceptionally(error);\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Completes the Future with the specified result.\r\n     * If the future has already completed (exceptionally\r\n     * or not), this method does nothing.\r\n     * @param result the result to complete with\r\n     * @returns `true` if this Future was completed by this method\r\n     */\r\n    complete(result) {\r\n        if (this._state != FutureState.INCOMPLETE)\r\n            return false;\r\n        this._result = result;\r\n        this._state = FutureState.COMPLETED_SUCCESS;\r\n        this._completionPromiseResolve(this._result);\r\n        return true;\r\n    }\r\n    /**\r\n     * Completes this Future with the result of the given supplier function.\r\n     * @param supplier a function returning the value to be used to complete this Future\r\n     */\r\n    completeAsync(supplier) {\r\n        if (supplier instanceof Function) {\r\n            supplier = supplier();\r\n        }\r\n        supplier.then(result => {\r\n            this.complete(result);\r\n        }, error => {\r\n            this.completeExceptionally(error);\r\n        });\r\n    }\r\n    /**\r\n     * Completes the Future with the specified error.\r\n     * If the future has already completed (exceptionally\r\n     * or not), this method does nothing.\r\n     * @param error the error\r\n     * @returns `true` if this Future was completed by this method\r\n     */\r\n    completeExceptionally(error) {\r\n        if (this._state != FutureState.INCOMPLETE)\r\n            return false;\r\n        this._error = error;\r\n        this._state = FutureState.COMPLETED_EXCEPTIONALLY;\r\n        this._completionPromiseReject(this._error);\r\n        return true;\r\n    }\r\n    /**\r\n     * If not already completed, completes this Future with a CancellationError. Dependent Futures that have\r\n     * not already completed will also complete exceptionally, with a CompletionError caused by this CancellationError.\r\n     * @returns `true` if this Future is now cancelled\r\n     */\r\n    cancel() {\r\n        if (this._state == FutureState.INCOMPLETE)\r\n            return false;\r\n        this._state = FutureState.CANCELLED;\r\n        this._error = new _error_CancellationError__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"Future was cancelled\");\r\n        this._completionPromiseReject(this._error);\r\n        return true;\r\n    }\r\n    /**\r\n     * Waits at most the given time (or if 0, indefinitely) for this future to complete,\r\n     * then resolves the returned Promise with the result, or rejects it\r\n     * with the exception that occurred (if any).\r\n     *\r\n     * @param timeout the timeout to wait, 0 waits indefinitely\r\n     * @param unit the unit in which the timeout is given\r\n     * @returns a Promise\r\n     *\r\n     * @throws {TimeoutError} if the timeout has been exceeded\r\n     * @throws {CompletionError} if the future completed exceptionally\r\n     */\r\n    get(timeout = 0, unit = _TimeUnit__WEBPACK_IMPORTED_MODULE_4__[\"default\"].MILLISECONDS) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (timeout == 0 || this.isDone())\r\n                return this._completionPromise;\r\n            let promiseResolve;\r\n            let promiseReject;\r\n            let promise = new Promise((resolve, reject) => {\r\n                promiseResolve = resolve;\r\n                promiseReject = reject;\r\n            });\r\n            unit.timeout(timeout, () => {\r\n                promiseReject(new _error_TimeoutError__WEBPACK_IMPORTED_MODULE_3__[\"default\"](timeout, unit, \"Future#get()\"));\r\n            });\r\n            this._completionPromise.then(result => {\r\n                promiseResolve(result);\r\n            }, error => {\r\n                promiseReject(new _error_Completion__WEBPACK_IMPORTED_MODULE_1__[\"default\"](error));\r\n            });\r\n            return promise;\r\n        });\r\n    }\r\n    /**\r\n     * Returns the result value (or throws any encountered exception) if completed, else returns the given `valueIfAbsent`.\r\n     * @param valueIfAbsent the value to return if not completed\r\n     * @returns the result value if completed, else the given `valueIfAbsent`\r\n     * @throws {CompletionError} if this future completed exceptionally or a completion computation threw an error\r\n     */\r\n    getNow(valueIfAbsent = null) {\r\n        if (!this.isDone())\r\n            return valueIfAbsent;\r\n        else if (this.isCompletedExceptionally())\r\n            throw new _error_Completion__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this._error);\r\n        else\r\n            return this._result;\r\n    }\r\n    /**\r\n     * Returns true if this Future was cancelled before it completed normally.\r\n     * @returns `true` if this Future was cancelled before it completed normally\r\n     */\r\n    isCancelled() {\r\n        return this._state == FutureState.CANCELLED;\r\n    }\r\n    /**\r\n     * Returns true if this Future completed exceptionally, in any way. Possible causes\r\n     * include cancellation, explicit invocation of {@link Future.completeExceptionally completeExceptionally()},\r\n     * and abrupt termination of an action.\r\n     * @returns `true` if this Future completed exceptionally\r\n     */\r\n    isCompletedExceptionally() {\r\n        return this._state == FutureState.COMPLETED_EXCEPTIONALLY;\r\n    }\r\n    /**\r\n     * Returns true if completed in any fashion: normally, exceptionally, or via cancellation.\r\n     * @returns `true` if completed\r\n     */\r\n    isDone() {\r\n        return (this._state & 2) > 0;\r\n    }\r\n    /**\r\n     * Forcibly sets or resets the value subsequently returned by method `get()` and related methods, whether or not\r\n     * already completed. This method is designed for use only in error recovery actions, and even such situations\r\n     * may result in ongoing dependent completions using estabilished versus overwritten outcomes.\r\n     * @param value the completion value\r\n     */\r\n    obtrudeValue(value) {\r\n        this._result = value;\r\n    }\r\n    /**\r\n     * Forcibly causes subsequent invocations of method `get()` and related methods to throw the given error, whether or not\r\n     * already completed. This method is designed for use only in error recovery actions, and even such situations\r\n     * may result in ongoing dependent completions using estabilished versus overwritten outcomes.\r\n     * @param error the error\r\n     */\r\n    obtrudeException(error) {\r\n        this._error = error;\r\n    }\r\n    /**\r\n     * Returns the estimated number of Futures whose completions are awaiting completion of this Future.\r\n     * This method is designed for use in monitoring system state, not for synchronization control.\r\n     * @returns the number of dependent Futures\r\n     */\r\n    getNumberOfDependents() {\r\n        return this._childrenCount;\r\n    }\r\n    /**\r\n     * Exceptionally completes this Future if not otherwise completed before the given timeout.\r\n     * @param timeout how long to wait before completing exceptionally, in units of `unit`\r\n     * @param unit a TimeUnit determining how to interpret the `timeout` parameter\r\n     * @returns this Future\r\n     */\r\n    orTimeout(timeout, unit = _TimeUnit__WEBPACK_IMPORTED_MODULE_4__[\"default\"].MILLISECONDS) {\r\n        unit.timeout(timeout, () => {\r\n            this.completeExceptionally(new _error_TimeoutError__WEBPACK_IMPORTED_MODULE_3__[\"default\"](timeout, unit, this));\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * Completes this Future with the given value if not otherwise completed before the given timeout.\r\n     * @param value the value to use upon timeout\r\n     * @param timeout how long to wait before completing normally with the given value, in units of `unit`\r\n     * @param unit a TimeUnit determining how to interpret the `timeout` parameter\r\n     * @returns this Future\r\n     */\r\n    completeOnTimeout(value, timeout, unit = _TimeUnit__WEBPACK_IMPORTED_MODULE_4__[\"default\"].MILLISECONDS) {\r\n        unit.timeout(timeout, () => {\r\n            this.complete(value);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this Future completes normally,\r\n     * is executed with this Future's result as the argument to the\r\n     * supplied function.\r\n     * @param fn the function to use to compute the value of the returned Future\r\n     * @template U the function's return type\r\n     * @returns the new Future\r\n     */\r\n    thenApply(fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            future.complete(fn(result));\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this Future completes normally,\r\n     * is executed with this Future's result as the argument to the\r\n     * supplied function.\r\n     * @param fn the function to use to compute the value of the returned Future\r\n     * @template U the function's return type\r\n     * @returns the new Future\r\n     */\r\n    thenApplyAsync(fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                fn(result).then(result => {\r\n                    future.complete(result);\r\n                }, error => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this Future completes normally,\r\n     * is executed with this Future's result as the argument to the\r\n     * supplied action.\r\n     * @param action the action to perform before completing the returned Future\r\n     * @returns the new Future\r\n     */\r\n    thenAccept(action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                action(result);\r\n                future.complete();\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this Future completes normally,\r\n     * is executed with this Future's result as the argument to the\r\n     * supplied action.\r\n     * @param action the action to perform before completing the returned Future\r\n     * @returns the new Future\r\n     */\r\n    thenAcceptAsync(action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                action(result).then(() => {\r\n                    future.complete();\r\n                }, error => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this Future completes normally,\r\n     * executes the given action.\r\n     * @param action the action to perform before completing the returned Future\r\n     * @returns the new Future\r\n     */\r\n    thenRun(action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(() => {\r\n            try {\r\n                action();\r\n                future.complete();\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this Future completes normally,\r\n     * executes the given action.\r\n     * @param action the action to perform before completing the returned Future\r\n     * @returns the new Future\r\n     */\r\n    thenRunAsync(action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(() => {\r\n            try {\r\n                action().then(() => {\r\n                    future.complete();\r\n                }, error => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this and the other given Future both complete normally,\r\n     * is executed with the two results as arguments to the supplied function.\r\n     * @param other the other Future\r\n     * @param fn the function to use to compute the value of the returned Future\r\n     * @template U the type of the other CompletionStage's result\r\n     * @template V the function's return type\r\n     * @returns the new future\r\n     */\r\n    thenCombine(other, fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        let oneFinished = false;\r\n        let firstResult;\r\n        let secondResult;\r\n        this._completionPromise.then(result => {\r\n            firstResult = result;\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    future.complete(fn(firstResult, secondResult));\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then((result) => {\r\n            secondResult = result;\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    future.complete(fn(firstResult, secondResult));\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this and the other given Future both complete normally,\r\n     * is executed with the two results as arguments to the supplied function.\r\n     * @param other the other Future\r\n     * @param fn the function to use to compute the value of the returned Future\r\n     * @template U the type of the other CompletionStage's result\r\n     * @template V the function's return type\r\n     * @returns the new future\r\n     */\r\n    thenCombineAsync(other, fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        let oneFinished = false;\r\n        let firstResult;\r\n        let secondResult;\r\n        this._completionPromise.then(result => {\r\n            firstResult = result;\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    fn(firstResult, secondResult).then(result => {\r\n                        future.complete(result);\r\n                    }, error => {\r\n                        future.completeExceptionally(error);\r\n                    });\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then((result) => {\r\n            secondResult = result;\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    fn(firstResult, secondResult).then(result => {\r\n                        future.complete(result);\r\n                    }, error => {\r\n                        future.completeExceptionally(error);\r\n                    });\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this and the other given Future both complete normally,\r\n     * is executed with the two results as arguments to the supplied action.\r\n     * @param other the other Future\r\n     * @param fn the action to perform before completing the returned Future\r\n     * @template U the type of the other CompletionStage's result\r\n     * @returns the new future\r\n     */\r\n    thenAcceptBoth(other, fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        let oneFinished = false;\r\n        let firstResult;\r\n        let secondResult;\r\n        this._completionPromise.then(result => {\r\n            firstResult = result;\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    fn(firstResult, secondResult);\r\n                    future.complete();\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then((result) => {\r\n            secondResult = result;\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    fn(firstResult, secondResult);\r\n                    future.complete();\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this and the other given Future both complete normally,\r\n     * is executed with the two results as arguments to the supplied action.\r\n     * @param other the other Future\r\n     * @param fn the action to perform before completing the returned Future\r\n     * @template U the type of the other CompletionStage's result\r\n     * @returns the new future\r\n     */\r\n    thenAcceptBothAsync(other, fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        let oneFinished = false;\r\n        let firstResult;\r\n        let secondResult;\r\n        this._completionPromise.then(result => {\r\n            firstResult = result;\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    fn(firstResult, secondResult).then(() => {\r\n                        future.complete();\r\n                    }, error => {\r\n                        future.completeExceptionally(error);\r\n                    });\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then((result) => {\r\n            secondResult = result;\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    fn(firstResult, secondResult).then(() => {\r\n                        future.complete();\r\n                    }, error => {\r\n                        future.completeExceptionally(error);\r\n                    });\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this and the other given Future both complete normally,\r\n     * executes the given action.\r\n     * @param other the other Future\r\n     * @param action the action to perform before completing the returned Future\r\n     * @returns the new future\r\n     */\r\n    runAfterBoth(other, action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        let oneFinished = false;\r\n        this._completionPromise.then(() => {\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    action();\r\n                    future.complete();\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then(() => {\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    action();\r\n                    future.complete();\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this and the other given Future both complete normally,\r\n     * executes the given action.\r\n     * @param other the other Future\r\n     * @param action the action to perform before completing the returned Future\r\n     * @returns the new future\r\n     */\r\n    runAfterBothAsync(other, action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        let oneFinished = false;\r\n        this._completionPromise.then(() => {\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    action().then(() => {\r\n                        future.complete();\r\n                    }, error => {\r\n                        future.completeExceptionally(error);\r\n                    });\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then(() => {\r\n            if (!oneFinished) {\r\n                oneFinished = true;\r\n            }\r\n            else {\r\n                try {\r\n                    action().then(() => {\r\n                        future.complete();\r\n                    }, error => {\r\n                        future.completeExceptionally(error);\r\n                    });\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when either this or the other given Future complete normally,\r\n     * is executed with the corresponding result as argument to the supplied function.\r\n     * @param other the other Future\r\n     * @param fn the function to use to compute the value of the returned Future\r\n     * @template U the function's return type\r\n     * @returns the new future\r\n     */\r\n    applyToEither(other, fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                future.complete(fn(result));\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then((result) => {\r\n            try {\r\n                future.complete(fn(result));\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when either this or the other given Future complete normally,\r\n     * is executed with the corresponding result as argument to the supplied function.\r\n     * @param other the other Future\r\n     * @param fn the function to use to compute the value of the returned Future\r\n     * @template U the function's return type\r\n     * @returns the new future\r\n     */\r\n    applyToEitherAsync(other, fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                fn(result).then(result => {\r\n                    future.complete(result);\r\n                }, error => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then((result) => {\r\n            try {\r\n                fn(result).then(result => {\r\n                    future.complete(result);\r\n                }, error => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when either this or the other given Future complete normally,\r\n     * is executed with the corresponding result as argument to the supplied action.\r\n     * @param other the other Future\r\n     * @param action the action to perform before completing the returned Future\r\n     * @returns the new future\r\n     */\r\n    acceptEither(other, action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                action(result);\r\n                future.complete();\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then((result) => {\r\n            try {\r\n                action(result);\r\n                future.complete();\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when either this or the other given Future complete normally,\r\n     * is executed with the corresponding result as argument to the supplied action.\r\n     * @param other the other Future\r\n     * @param action the action to perform before completing the returned Future\r\n     * @returns the new future\r\n     */\r\n    acceptEitherAsync(other, action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                action(result).then(() => {\r\n                    future.complete();\r\n                }, error => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then((result) => {\r\n            try {\r\n                action(result).then(() => {\r\n                    future.complete();\r\n                }, error => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when either this or the other given Future complete normally,\r\n     * executes the given action.\r\n     * @param other the other Future\r\n     * @param action the action to perform before completing the returned Future\r\n     * @returns the new future\r\n     */\r\n    runAfterEither(other, action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(() => {\r\n            try {\r\n                action();\r\n                future.complete();\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then(() => {\r\n            try {\r\n                action();\r\n                future.complete();\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when either this or the other given Future complete normally,\r\n     * executes the given action.\r\n     * @param other the other Future\r\n     * @param action the action to perform before completing the returned Future\r\n     * @returns the new future\r\n     */\r\n    runAfterEitherAsync(other, action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(() => {\r\n            try {\r\n                action().then(() => {\r\n                    future.complete();\r\n                }, error => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        other._completionPromise.then(() => {\r\n            try {\r\n                action().then(() => {\r\n                    future.complete();\r\n                }, error => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, (error) => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that is completed with the same value as the future returned\r\n     * by the given function.\r\n     *\r\n     * When this future completes normally, the given function is invoked with this future's\r\n     * result as the argument, returning another Future. When that future completes normally,\r\n     * the future returned by this method is completed with the same value.\r\n     *\r\n     * To ensure progress, the supplied function must arrange eventual completion of its result.\r\n     * @param fn the function to use to compute another Future\r\n     * @template U the type of the returned future's result\r\n     * @returns the new Future\r\n     */\r\n    thenCompose(fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            fn(result).handle((result, error) => {\r\n                if (error) {\r\n                    future.completeExceptionally(error);\r\n                }\r\n                else {\r\n                    future.complete(result);\r\n                }\r\n            });\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that is completed with the same value as the future returned\r\n     * by the given function.\r\n     *\r\n     * When this future completes normally, the given function is invoked with this future's\r\n     * result as the argument, returning another Future. When that future completes normally,\r\n     * the future returned by this method is completed with the same value.\r\n     *\r\n     * To ensure progress, the supplied function must arrange eventual completion of its result.\r\n     * @param fn the function to use to compute another Future\r\n     * @template U the type of the returned future's result\r\n     * @returns the new Future\r\n     */\r\n    thenComposeAsync(fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                fn(result).then(result => {\r\n                    result.handle((result, error) => {\r\n                        if (error) {\r\n                            future.completeExceptionally(error);\r\n                        }\r\n                        else {\r\n                            future.complete(result);\r\n                        }\r\n                    });\r\n                }, error => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n            }\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future with the same result or exception as this future, that executes\r\n     * the given action when this future completes.\r\n     *\r\n     * When this future is complete, the given action is invoked with the result (or `null`\r\n     * if none) and the exception (or `null` if none) of this future as arguments. The returned\r\n     * future is completed when the action returns.\r\n     *\r\n     * Unlike the {@link Future.handle() `handle()`} method, this method is not designed to\r\n     * translate completion outcomes, so the supplied action should not throw an exception.\r\n     * However, if it does, the following rules apply:\r\n     * - if this future completed normally but the supplied action throws an exception,\r\n     *   then the returned future completes exceptionally with the supplied action's exception\r\n     * - if this future completed exceptionally, and the supplied action throws an exception,\r\n     *   then the returned future completes exceptionally with this future's exception\r\n     * @param action the action to perform\r\n     * @returns the new Future\r\n     */\r\n    whenComplete(action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                action(result, null);\r\n                future.complete(result);\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(error);\r\n            }\r\n        }, error => {\r\n            try {\r\n                action(null, error);\r\n            }\r\n            catch (_error) { }\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future with the same result or exception as this future, that executes\r\n     * the given action when this future completes.\r\n     *\r\n     * When this future is complete, the given action is invoked with the result (or `null`\r\n     * if none) and the exception (or `null` if none) of this future as arguments. The returned\r\n     * future is completed when the action returns.\r\n     *\r\n     * Unlike the {@link Future.handle() `handle()`} method, this method is not designed to\r\n     * translate completion outcomes, so the supplied action should not throw an exception.\r\n     * However, if it does, the following rules apply:\r\n     * - if this future completed normally but the supplied action throws an exception,\r\n     *   then the returned future completes exceptionally with the supplied action's exception\r\n     * - if this future completed exceptionally, and the supplied action throws an exception,\r\n     *   then the returned future completes exceptionally with this future's exception\r\n     * @param action the action to perform\r\n     * @returns the new Future\r\n     */\r\n    whenCompleteAsync(action) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                action(result, null).then(() => {\r\n                    future.complete(result);\r\n                }, error => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(error);\r\n            }\r\n        }, error => {\r\n            try {\r\n                action(null, error).then(() => {\r\n                    future.completeExceptionally(error);\r\n                }, () => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (_error) { }\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future with the same result or exception as this future, that executes\r\n     * one of the given actions when this future completes.\r\n     *\r\n     * When this future is complete, one of the given actions is invoked with the result\r\n     * or the exception of this future as arguments, respectively. The returned\r\n     * future is completed when the called action returns.\r\n     *\r\n     * Unlike the {@link Future.handle() `handle()`} method, this method is not designed to\r\n     * translate completion outcomes, so the supplied actions should not throw exceptions.\r\n     * However, if it does, the following rules apply:\r\n     * - if this future completed normally but the supplied action throws an exception,\r\n     *   then the returned future completes exceptionally with the supplied action's exception\r\n     * - if this future completed exceptionally, and the supplied action throws an exception,\r\n     *   then the returned future completes exceptionally with this future's exception\r\n     * @param onResult the action to perform when the future completes successfully\r\n     * @param onError the action to perform when the future completes exceptionally\r\n     * @returns the new Future\r\n     */\r\n    whenCompleteBoth(onResult, onError) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                onResult(result);\r\n                future.complete(result);\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(error);\r\n            }\r\n        }, error => {\r\n            try {\r\n                onError(error);\r\n            }\r\n            catch (_error) { }\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future with the same result or exception as this future, that executes\r\n     * one of the given actions when this future completes.\r\n     *\r\n     * When this future is complete, one of the given actions is invoked with the result\r\n     * or the exception of this future as arguments, respectively. The returned\r\n     * future is completed when the called action returns.\r\n     *\r\n     * Unlike the {@link Future.handle() `handle()`} method, this method is not designed to\r\n     * translate completion outcomes, so the supplied actions should not throw exceptions.\r\n     * However, if it does, the following rules apply:\r\n     * - if this future completed normally but the supplied action throws an exception,\r\n     *   then the returned future completes exceptionally with the supplied action's exception\r\n     * - if this future completed exceptionally, and the supplied action throws an exception,\r\n     *   then the returned future completes exceptionally with this future's exception\r\n     * @param onResult the action to perform when the future completes successfully\r\n     * @param onError the action to perform when the future completes exceptionally\r\n     * @returns the new Future\r\n     */\r\n    whenCompleteBothAsync(onResult, onError) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                onResult(result).then(() => {\r\n                    future.complete(result);\r\n                }, (error) => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(error);\r\n            }\r\n        }, error => {\r\n            try {\r\n                onError(error).then(() => {\r\n                    future.completeExceptionally(error);\r\n                }, () => {\r\n                    future.completeExceptionally(error);\r\n                });\r\n            }\r\n            catch (_error) { }\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this future completes either normally or exceptionally, is executed with this future's\r\n     * result and exception as arguments to the supplied function.\r\n     *\r\n     * When this future is complete, the given function is invoked with the result (or `null` if none) and the exception (or\r\n     * `null` if none) of this future as arguments, and the function's result is used to complete the returned future.\r\n     * @param fn the action to perform\r\n     * @template U the function's return type\r\n     * @returns the new Future\r\n     */\r\n    handle(fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                future.complete(fn(result, null));\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(error);\r\n            }\r\n        }, error => {\r\n            try {\r\n                future.complete(fn(null, error));\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(error);\r\n            }\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this future completes either normally or exceptionally, is executed with this future's\r\n     * result and exception as arguments to the supplied function.\r\n     *\r\n     * When this future is complete, the given function is invoked with the result (or `null` if none) and the exception (or\r\n     * `null` if none) of this future as arguments, and the function's result is used to complete the returned future.\r\n     * @param fn the action to perform\r\n     * @template U the function's return type\r\n     * @returns the new Future\r\n     */\r\n    handleAsync(fn) {\r\n        let future = new Future();\r\n        this._childrenCount++;\r\n        this._completionPromise.then(result => {\r\n            try {\r\n                fn(result, null).then(result => {\r\n                    future.complete(result);\r\n                }, error => {\r\n                    future.complete(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(error);\r\n            }\r\n        }, error => {\r\n            try {\r\n                fn(null, error).then(result => {\r\n                    future.complete(result);\r\n                }, error => {\r\n                    future.complete(error);\r\n                });\r\n            }\r\n            catch (error) {\r\n                future.completeExceptionally(error);\r\n            }\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that, when this future completes exceptionally, is executed\r\n     * with this future's exception as the argument to the supplied function. Otherwise,\r\n     * if this future completes normally, then the returned future also completes normally\r\n     * with the same value.\r\n     * @param fn the value, or the function whose value will be used to complete the returned Future if this Future completes exceptionally\r\n     * @returns the new Future\r\n     */\r\n    exceptionally(fn) {\r\n        let future = new Future();\r\n        this._completionPromise.then(result => {\r\n            future.complete(result);\r\n        }, error => {\r\n            if (fn instanceof Function) {\r\n                try {\r\n                    future.complete(fn(error));\r\n                }\r\n                catch (error) {\r\n                    future.completeExceptionally(new _error_ExecutionError__WEBPACK_IMPORTED_MODULE_2__[\"default\"](error));\r\n                }\r\n            }\r\n            else {\r\n                future.complete(fn);\r\n            }\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that is already completed with the given value.\r\n     * @param value the value\r\n     * @template U the type of the value\r\n     * @returns the completed Future\r\n     */\r\n    static completedFuture(value) {\r\n        let future = new Future();\r\n        future.complete(value);\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that is already completed exceptionally with the given exception.\r\n     * @param error the error\r\n     * @template U the type of the value\r\n     * @returns the exceptionally completed Future\r\n     */\r\n    static failedFuture(error) {\r\n        let future = new Future();\r\n        future.completeExceptionally(error);\r\n        return future;\r\n    }\r\n    /**\r\n     * Creates a Future from the specified Promise or async function.\r\n     * @param promise the Promise or async function to use\r\n     * @template U the type of the initial Promise\r\n     * @returns the created Future\r\n     */\r\n    static asyncFuture(promise) {\r\n        let future = new Future();\r\n        if (promise instanceof Function)\r\n            promise = promise();\r\n        promise.then(result => {\r\n            future.complete(result);\r\n        }, error => {\r\n            future.completeExceptionally(error);\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that is completed when all of the given Futures complete. If any of the given futures\r\n     * complete exceptionally, then the returned Future also does so, with a CompletionError holding this error as\r\n     * its cause. Otherwise, the results, if any, of the given Futures are not reflected in the returned Future, but\r\n     * may be obtained by inspecting them individually. If no Futures are provided, this method returns a Future\r\n     * completed with the value null.\r\n     * @param  {...Future<*>} futures the futures\r\n     * @returns a new Future that is completed when all of the given Futures complete\r\n     */\r\n    static allOf(...futures) {\r\n        if (futures.length == 0)\r\n            return this.completedFuture(null);\r\n        let future = new Future();\r\n        let count = 0;\r\n        futures.forEach(f => {\r\n            f.handle((_result, error) => {\r\n                if (error) {\r\n                    future.completeExceptionally(new _error_Completion__WEBPACK_IMPORTED_MODULE_1__[\"default\"](undefined, error));\r\n                }\r\n                else {\r\n                    if (++count == futures.length) {\r\n                        future.complete(undefined);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        return future;\r\n    }\r\n    /**\r\n     * Returns a new Future that is completed when any of the given Futures complete, with the same result. Otherwise,\r\n     * if it completed exceptionally, the returned Future also does so, with a CompletionError holding this exception\r\n     * as its cause. If no futures are provided, this method returns an incomplete Future.\r\n     * @param  {...Future<any>} futures the futures\r\n     * @returns a new Future that is completed with the result or exception of any of the given futures when one completes\r\n     */\r\n    static anyOf(...futures) {\r\n        let future = new Future();\r\n        futures.forEach(f => {\r\n            f.handle((result, error) => {\r\n                if (error)\r\n                    future.completeExceptionally(error);\r\n                else\r\n                    future.complete(result);\r\n            });\r\n        });\r\n        return future;\r\n    }\r\n}\r\n_a = Symbol.toStringTag;\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/util/Future.ts?");

/***/ }),

/***/ "./src/rpe/util/TimeUnit.ts":
/*!**********************************!*\
  !*** ./src/rpe/util/TimeUnit.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TimeUnit)\n/* harmony export */ });\nclass TimeUnit {\r\n    constructor(name, singular, plural, timeInMillis) {\r\n        this._name = name;\r\n        this._singular = singular;\r\n        this._plural = plural;\r\n        this._timeInMillis = timeInMillis;\r\n    }\r\n    /**\r\n     * Converts the specified duration from the specified TimeUnit into this one.\r\n     * Example usage:\r\n     * ```\r\n     * //  24 hours          <--          1 days\r\n     * //TimeUnit.HOURS      <--       TimeUnit.DAYS\r\n     *   TimeUnit.HOURS.convertFrom(1, TimeUnit.DAYS); // 24\r\n     * ```\r\n     * @param sourceDuration the source duration to convert\r\n     * @param sourceUnit the unit in which the sourceDuration is given\r\n     * @see {@link TimeUnit.convertTo}\r\n     * @returns the resulting duration\r\n     */\r\n    convertFrom(sourceDuration, sourceUnit) {\r\n        return sourceDuration * sourceUnit._timeInMillis / this._timeInMillis;\r\n    }\r\n    /**\r\n     * Converts the specified duration from this TimeUnit into the specified one.\r\n     * Example usage:\r\n     * ```\r\n     * //   1 days          -->        24 hours\r\n     * //TimeUnit.DAYS      -->     TimeUnit.HOURS\r\n     *   TimeUnit.DAYS.convertTo(1, TimeUnit.HOURS); // 24\r\n     * ```\r\n     * @param sourceDuration the source duration to convert\r\n     * @param targetUnit the target TimeUnit to convert to\r\n     * @returns the resulting duration\r\n     */\r\n    convertTo(sourceDuration, targetUnit) {\r\n        return sourceDuration * this._timeInMillis / targetUnit._timeInMillis;\r\n    }\r\n    /**\r\n     * Performs a timed `setTimeout` using this time unit.\r\n     * Given the variable `result`, the following statements are equivalent:\r\n     * ```\r\n     * result = TimeUnit.SECONDS.timeout(0.5, ()=>{\r\n     *     console.log(\"done\");\r\n     * });\r\n     *\r\n     * result = TimeUnit.MILLISECONDS.timeout(500, ()=>{\r\n     *     console.log(\"done\")\r\n     * }));\r\n     *\r\n     * result = setTimeout(()=>{\r\n     *     console.log(\"done\");\r\n     * }, 500);\r\n     * ```\r\n     * @param timeout the duration in this TimeUnit to time out\r\n     * @param callback the function to run\r\n     * @param params any additional arguments to supply to the function\r\n     * @returns the created timeout id\r\n     */\r\n    timeout(timeout, callback, ...params) {\r\n        return setTimeout(callback, timeout * this._timeInMillis, ...params);\r\n    }\r\n    /**\r\n     * Performs a timed `setInterval` using this time unit.\r\n     * Given the variable `result`, the following statements are equivalent:\r\n     * ```\r\n     * result = TimeUnit.SECONDS.interval(0.5, ()=>{\r\n     *     console.log(\"done\");\r\n     * });\r\n     *\r\n     * result = TimeUnit.MILLISECONDS.interval(500, ()=>{\r\n     *     console.log(\"done\")\r\n     * }));\r\n     *\r\n     * result = setInterval(()=>{\r\n     *     console.log(\"done\");\r\n     * }, 500);\r\n     * ```\r\n     * @param interval the interval in this TimeUnit to repeat at\r\n     * @param callback the function to run periodically\r\n     * @param params any additional arguments to supply to the function\r\n     * @returns the created interval id\r\n     */\r\n    interval(interval, callback, ...params) {\r\n        return setInterval(callback, interval * this._timeInMillis, ...params);\r\n    }\r\n    /**\r\n     * Converts the specified duration into days.\r\n     * Equivalent to {@link TimeUnit.convertTo convertTo(duration, TimeUnit.DAYS)}.\r\n     * @param duration the duration to convert\r\n     */\r\n    toDays(duration) {\r\n        return this.convertTo(duration, TimeUnit.DAYS);\r\n    }\r\n    /**\r\n     * Converts the specified duration into hours.\r\n     * Equivalent to {@link TimeUnit.convertTo convertTo(duration, TimeUnit.HOURS)}.\r\n     * @param duration the duration to convert\r\n     */\r\n    toHours(duration) {\r\n        return this.convertTo(duration, TimeUnit.HOURS);\r\n    }\r\n    /**\r\n     * Converts the specified duration into minutes.\r\n     * Equivalent to {@link TimeUnit.convertTo convertTo(duration, TimeUnit.MINUTES)}.\r\n     * @param duration the duration to convert\r\n     */\r\n    toMinutes(duration) {\r\n        return this.convertTo(duration, TimeUnit.MINUTES);\r\n    }\r\n    /**\r\n     * Converts the specified duration into seconds.\r\n     * Equivalent to {@link TimeUnit.convertTo convertTo(duration, TimeUnit.SECONDS)}.\r\n     * @param duration the duration to convert\r\n     */\r\n    toSeconds(duration) {\r\n        return this.convertTo(duration, TimeUnit.SECONDS);\r\n    }\r\n    /**\r\n     * Converts the specified duration into milliseconds.\r\n     * Equivalent to {@link TimeUnit.convertTo convertTo(duration, TimeUnit.MILLISECONDS)}.\r\n     * @param duration the duration to convert\r\n     */\r\n    toMillis(duration) {\r\n        return duration * this._timeInMillis;\r\n    }\r\n    /**\r\n     * Converts the specified duration into microseconds.\r\n     * Equivalent to {@link TimeUnit.convertTo convertTo(duration, TimeUnit.MICROSECONDS)}.\r\n     * @param duration the duration to convert\r\n     */\r\n    toMicros(duration) {\r\n        return this.convertTo(duration, TimeUnit.MICROSECONDS);\r\n    }\r\n    /**\r\n     * Converts the specified duration into nanoseconds.\r\n     * Equivalent to {@link TimeUnit.convertTo convertTo(duration, TimeUnit.NANOSECONDS)}.\r\n     * @param duration the duration to convert\r\n     */\r\n    toNanos(duration) {\r\n        return this.convertTo(duration, TimeUnit.NANOSECONDS);\r\n    }\r\n    name() {\r\n        return this._name;\r\n    }\r\n    toString() {\r\n        return this._name;\r\n    }\r\n    /**\r\n     * Appends the time unit to the specified duration.\r\n     * @param duration the duration\r\n     * @returns the resulting string\r\n     */\r\n    stringify(duration) {\r\n        return (duration ? duration + \" \" : \"unknown \") + (duration == 1 ? this._singular : this._plural);\r\n    }\r\n}\r\n/**\r\n * Time unit representing twenty four {@link TimeUnit.HOURS hours}.\r\n */\r\nTimeUnit.DAYS = new TimeUnit(\"DAYS\", \"day\", \"days\", 24 * 60 * 60 * 1000);\r\n/**\r\n * Time unit representing sixty {@link TimeUnit.MINUTES minutes}.\r\n */\r\nTimeUnit.HOURS = new TimeUnit(\"HOURS\", \"hour\", \"hours\", 60 * 60 * 1000);\r\n/**\r\n * Time unit representing sixty {@link TimeUnit.SECONDS seconds}.\r\n */\r\nTimeUnit.MINUTES = new TimeUnit(\"MINUTES\", \"minute\", \"minutes\", 60 * 1000);\r\n/**\r\n * Time unit representing one second, or a thousand {@link TimeUnit.MILLISECONDS milliseconds}.\r\n */\r\nTimeUnit.SECONDS = new TimeUnit(\"SECONDS\", \"second\", \"seconds\", 1000);\r\n/**\r\n * Time unit representing one thousandth (0.001) of a {@link TimeUnit.SECONDS second}.\r\n */\r\nTimeUnit.MILLISECONDS = new TimeUnit(\"MILLISECONDS\", \"millisecond\", \"milliseconds\", 1);\r\n/**\r\n * Time unit representing one thousandth (0.001) of a {@link TimeUnit.MILLISECONDS millisecond}.\r\n */\r\nTimeUnit.MICROSECONDS = new TimeUnit(\"MICROSECONDS\", \"microsecond\", \"microseconds\", 0.001);\r\n/**\r\n * Time unit representing one thousandth (0.001) of a {@link TimeUnit.MICROSECONDS microsecond}.\r\n */\r\nTimeUnit.NANOSECONDS = new TimeUnit(\"NANOSECONDS\", \"nanosecond\", \"nanoseconds\", 0.000001);\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/util/TimeUnit.ts?");

/***/ }),

/***/ "./src/rpe/util/Utils.ts":
/*!*******************************!*\
  !*** ./src/rpe/util/Utils.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Future__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Future */ \"./src/rpe/util/Future.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nconst Utils = {\r\n    SVG_NAMESPACE: \"http://www.w3.org/2000/svg\",\r\n    XLINK_NAMESPACE: \"http://www.w3.org/1999/xlink\",\r\n    NATURAL_COLLATOR: new Intl.Collator(undefined, { numeric: true }),\r\n    /**\r\n     * Returns the contents of the specified url.\r\n     * @param url the URL to get\r\n     * @param optionsConsumer request init data\r\n     * @param progressConsumer a callback containing\r\n     */\r\n    getLargeFileBlob(url, fetchOptions, progressConsumer) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let fetchResult = yield fetch(url, fetchOptions);\r\n            let reader = fetchResult.body.getReader();\r\n            let array = [];\r\n            let read = 0;\r\n            let length = parseInt(fetchResult.headers.get(\"Content-Length\"));\r\n            if (!progressConsumer)\r\n                progressConsumer = () => { };\r\n            while (true) {\r\n                let result = yield reader.read();\r\n                if (result.done)\r\n                    break;\r\n                read += result.value.length;\r\n                progressConsumer(read, length);\r\n                array.push(result.value);\r\n            }\r\n            return new Blob(array);\r\n        });\r\n    },\r\n    /**\r\n     * Creates a new HTML element, and optionally adds an ID and/or classes to it.\r\n     * @param type the type of the element (e.g. div)\r\n     * @param parent an optional parent to add this element to\r\n     * @param id an optional id to add to this element\r\n     * @param classes an optional list of classes to add to this element\r\n     * @returns the resulting HTMLElement\r\n     */\r\n    dom(type, parent, id, ...classes) {\r\n        let e = document.createElement(type);\r\n        if (id)\r\n            e.id = id;\r\n        if (classes && classes.length > 0)\r\n            e.classList.add(...classes);\r\n        if (parent)\r\n            parent.appendChild(e);\r\n        return e;\r\n    },\r\n    /**\r\n     * Creates a new namespaced HTML element, and optionally adds an ID and/or classes to it.\r\n     * @param namespace the namespace of this element (e.g. http://www.w3.org/2000/svg)\r\n     * @param type the type of the element (e.g. div)\r\n     * @param parent an optional parent to add this element to\r\n     * @param id an optional id to add to this element\r\n     * @param  {...string} classes an optional list of classes to add to this element\r\n     * @returns the resulting HTMLElement\r\n     */\r\n    domNS(namespace, type, parent, id, ...classes) {\r\n        let e = document.createElementNS(namespace, type);\r\n        if (id)\r\n            e.id = id;\r\n        if (classes && classes.length > 0)\r\n            e.classList.add(...classes);\r\n        if (parent)\r\n            parent.appendChild(e);\r\n        return e;\r\n    },\r\n    /**\r\n     * Creates a new <svg> element, with a <use> element containing a link, and optionally adds an ID and/or classes to it.\r\n     * @param useLink the link to use within the <use> element (the xlink:href property)\r\n     * @param id an optional id to add to this element\r\n     * @param  {...string} classes an optional list of classes to add to this element\r\n     * @returns the resulting HTMLElement\r\n     */\r\n    svgUse(useLink, id, ...classes) {\r\n        let svg = this.domNS(this.SVG_NAMESPACE, \"svg\", id, ...classes);\r\n        let use = this.domNS(this.SVG_NAMESPACE, \"use\");\r\n        use.setAttributeNS(this.XLINK_NAMESPACE, \"xlink:href\", useLink);\r\n        svg.appendChild(use);\r\n        return svg;\r\n    },\r\n    /**\r\n     * Updates the specified <svg> object's <use> element link attribute to the specified value.\r\n     * @param svg the svg acquired from newSvgUse()\r\n     * @param newUseLink the new link\r\n     */\r\n    updateSvgUse(svg, newUseLink) {\r\n        svg.children[0].setAttributeNS(this.XLINK_NAMESPACE, \"xlink:href\", newUseLink);\r\n    },\r\n    /**\r\n     * Clears the children elements of the specified element.\r\n     * @param element the element\r\n     */\r\n    clearChildren(element) {\r\n        while (element.firstChild) {\r\n            element.removeChild(element.lastChild);\r\n        }\r\n    },\r\n    /**\r\n     * Performs a binary search on the specified ordered array for the specified element.\r\n     * If the object is found within the array, the index of the element is returned.\r\n     *\r\n     * Let x be the position at which the element should be placed in the array.\r\n     * If the object is not found within the array, this method will return -(x + 1).\r\n     * @param array the ordered array to search\r\n     * @param element the element to search for\r\n     * @param compareFunction the function to use for comparing elements\r\n     * @returns the index of the element, or the insertion index\r\n     */\r\n    binarySearch(array, element, compareFunction) {\r\n        var m = 0;\r\n        var n = array.length - 1;\r\n        while (m <= n) {\r\n            var k = (n + m) >> 1;\r\n            var cmp = compareFunction(element, array[k]);\r\n            if (cmp > 0) {\r\n                m = k + 1;\r\n            }\r\n            else if (cmp < 0) {\r\n                n = k - 1;\r\n            }\r\n            else {\r\n                return k;\r\n            }\r\n        }\r\n        return -m - 1;\r\n    },\r\n    /**\r\n     * Loads the image at the specified source URL in an asynchronous way.\r\n     * @param src the URL to load the image from\r\n     * @returns a Future which will complete with an Image object\r\n     */\r\n    loadImageAsync(src) {\r\n        let f = new _Future__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n        const img = new Image();\r\n        img.onload = () => f.complete(img);\r\n        img.onerror = f.completeExceptionally;\r\n        img.src = src;\r\n        return f;\r\n    },\r\n    /**\r\n     * Loads the specified script in an asynchronous way.\r\n     * @param scriptSourceURL the URL of the script\r\n     * @param parent the parent HTMLElement to append to\r\n     * @returns a new Future\r\n     */\r\n    loadScript(scriptSourceURL, parent = document.head) {\r\n        let future = new _Future__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n        let script = this.dom(\"script\");\r\n        script.onload = () => future.complete();\r\n        script.onerror = (e) => future.completeExceptionally(e);\r\n        script.src = scriptSourceURL;\r\n        return future;\r\n    },\r\n    /**\r\n     * Returns a comparator function using natural sorting\r\n     * for the specified type, using the specified string\r\n     * extractor function.\r\n     * @param func string extractor function\r\n     * @template T the original type\r\n     * @returns the comparator function\r\n     */\r\n    naturalComparator(func = a => a ? a.toString() : \"null\") {\r\n        return (a, b) => {\r\n            return this.NATURAL_COLLATOR.compare(func(a), func(b));\r\n        };\r\n    },\r\n    /**\r\n     * Sorts the array of type T `array` naturally, with\r\n     * the string extractor function `func`.\r\n     * @param array the array to sort\r\n     * @param func the string extractor function\r\n     * @returns the same array\r\n     * @template T the original type\r\n     */\r\n    naturalSort(array, func = a => a ? a.toString() : \"null\") {\r\n        array.sort(this.naturalComparator(func));\r\n        return array;\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Utils);\r\n\n\n//# sourceURL=webpack://resourcepackeditor-browser/./src/rpe/util/Utils.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"core": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkresourcepackeditor_browser"] = self["webpackChunkresourcepackeditor_browser"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;